# Evaluation
여기선 SpEL 인터페이스와 표현식 언어를 프로그래밍적으로 사용하는 방법을 소개한다. 

아래는 SpEL API 를 사용해 문자열 리터럴 표현식을 평가하는 방법을 보여준다.
```java
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'");
String message = (String) exp.getValue();
// 그 결과 message 변수의 값은 "Hello World" 이다.
```

주로 사용할 SpEL 클래스와 인터페이스는 `org.springframework.expression` 패키지와 `spel.support` 같은 그 하위 패키지에 있다. 

## ExpressionParser, Expression
- `ExpressionParser` 인터페이스는 표현식 문자열을 파싱하는 역할이다.
    - 앞선 예제에서의 표현식은 작은따옴표로 싸인 '문자열 리터럴' 이었다.
    - 구문 분석, 즉 파싱만 전담하며 AST(추상 구문 트리)만 생성하고 문법 오류를 확인
    - ㄴ실제 메서드 호출이나 값 계산은 이루어지지 않는다.
- `Expression` 인터페이스는 정의된 표현식을 평가하는 역할이다. 
    - getValue() 호출 시에 AST 를 따라가며 실제 메서드 호출, 프로퍼티 접근 등 논리적 행동이 수행된다.
- 예외
    - `parser.parseExpression()` 호출 시엔 `ParseException`
    - `exp.getValue()` 호출 시엔 `EvalutionException` 이 발생할 수 있음

## SpEL 의 기능 사용
SpEL 은 메서드 호출, 프로퍼티 접근, 생성자 호출 등의 많은 기능을 제공한다.

아래 메서드 호출 예제에선 문자열 리터럴 'Hello World' 에서 concat 을 호출한다.
```java
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'.concat('!')"); // 메서드 호출 
String message = (String) exp.getValue();
// 그 결과 message 변숫값은 "Hello World!" 가 된다.
```

다음은 'Hello World' 의 JavaBean 프로퍼티인 bytes 에 접근한다.

```java
ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes()'
Expression exp = parser.parseExpression("'Hello World'.bytes"); // bytes 에 접근
byte[] bytes = (byte[]) exp.getValue();
// 그 결과 bytes 의 결과는 리터럴을 byte array 로 변환한 값이다.
```

**SpEL 은 또한 표준 점 표기법을 사용하여 중첩 프로퍼티 접근과 설정을 지원한다. public 필드도 접근 가능하다.**
```
점 표기법 prop1.prop2.prop3
```

아래는 점 표기법으로 문자열 리터럴의 길이를 구한다.
```java
ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression("'Hello World'.bytes.length");
int length = (Integer) exp.getValue();
// length 값은 리터럴의 길이가 된다.
```

아래처럼 문자열 리터럴 대신 new String 으로 생성자 호출을 할 수도 있다.
```java
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("new String('hello world').toUpperCase()");
String message = exp.getValue(String.class);
// 새로운 String 이 만들어지고 대문자로 변환된다.
```
`public <T> T getValue(Class<T> desiredResultType)` 사용
- 이 메서드를 사용하면 결과를 원하는 타입으로 캐스팅하는 작업을 안해도 된다.
- 값이 T 로 캐스팅될 수 없거나 등록된 타입 컨버터로 변환이 불가하다면 `EvalutionException` 을 던진다.

**SpEL 의 더 일반적인 사용법은 특정 객체 인스턴스를 대상으로 평가하는 표현식을 사용하는 것이다.**

아래는 Inventor 인스턴스에서 name 프로퍼티를 조회하고 boolean 표현식에서 참조하는 방법을 보여준다.
```java
// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression("name"); // Parse name as an expression
String name = (String) exp.getValue(tesla);
// name == "Nikola Tesla"

exp = parser.parseExpression("name == 'Nikola Tesla'");
boolean result = exp.getValue(tesla, Boolean.class);
// result == true
```

- `parser.parserExpression("name")`: 단지 루트 객체의 name 프로퍼티에 접근하라는 AST 를 만들어라 이다. 따라서 이 시점에선 어떤 객체의 name 인지는 모른다. 
- `exp.getValue(tesla)`: 이때 객체 tesla 와 바인딩하여 인스턴스의 name 을 가져온다.
- `parser.parseExpressio("name == 'Nikola Tesla'")`: name 을 참조하여 같은지 평가한 값 반환
- `exp.getValue(tesla, Boolean.class)`: 평가 후 반환된 값을 Boolean 형으로 받겠다.

## Understanding EvaluationContext
EvaluationContext API 는 표현식 평가 시 프로퍼티, 메서드, 필드 해석과 타입 변환을 돕는다.

스프링은 두 가지 구현을 제공한다.
- **SimpleEvaluationContext**
    - 필수 SpEL 기능과 설정 옵션의 부분집합, 즉, 일부만 노출한다.
    - 따라서 SpEL 전체 문법이 필요 없고 제한되어야 하는 표현식에 적합하다.
    - SpEL 문법의 일부만을 제공한다.
        - Java 타입 참조나 생성자, 빈 참조는 사용할 수 없다.
    - ex. 데이터 바인딩 표현식, 프로퍼티 기반 필터
- **StandardEvalutionContext**
    - SpEL 기능과 설정 옵션 전체를 제공한다.
    - 기본 루트 객체 설정과 모든 가능한 평가 전략 설정이 가능하다.
- SimpleEvaluationContext 은 표현식에서 데이터 바인딩 지원 수준을 선택해야 한다.
    - SimpleEvaluationContext.forReadOnlyDataBinding(): Data binding for read-only access
    - SimpleEvaluationContext.forReadWriteDataBinding(): Data binding for read and write access
    - SimpleEvaluationContext.forPropertyAccessors(…): 사용자 정의 PropertyAcessor, 필요시 DataBindingPropertyAccessor 와 결합

___

### Type Conversion
- 기본적으로 SpEL 은 ConversionService, `org.springframework.core.convert.ConversionService` 을 사용한다.
- ConversionService 특징
    - 일반적인 변환용 내장 컨버터를 가지지만, 확장도 가능하며 사용자 정의 타입 변환을 추가할 수 있다.
    - 또한 generics-aware 하다.
    - 따라서 제네릭 타입을 표현식에서 사용할 수 있으며, 타입 일관성을 유지하도록 적절한 변환을 시도한다.
    - 만약, setValue() 로 List 프로퍼티에 값을 넣는다고 할 때, 실제 프로퍼티의 타입이 `List<Boolean>` 이면 SpEL 은 요소를 Boolean 으로 변환하여 list 에 넣어야 함을 인식한다.
```java
class Simple {
	public List<Boolean> booleanList = new ArrayList<>();
}

Simple simple = new Simple();
simple.booleanList.add(true);

// read-only
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// "false" is passed in here as a String. SpEL and the conversion service
// will recognize that it needs to be a Boolean and convert it accordingly.
Expression exp = parser.parseExpression("booleanList[0]");
exp.setValue(context, simple, "false"); // false 를 boolean 으로 변환하여 넣는다.

// b is false
Boolean b = simple.booleanList.get(0);
```

## Parser Configuration
- `SpelParserConfiguration` 를 사용하여 SpEL 표현식 파서를 설정 가능하다.
    - `org.springframework.expression.spel.SpelParserConfiguration`
- 설정 객체를 통해 표현식 컴포넌트의 행동을 제어할 수 있다. 
    - 예를 들어 컬렉션을 인덱싱했는데 해당 위치가 null 이라면 요소를 자동 생성하도록 할 수 있다.
    - 이는 체이닝 프로퍼티 참조에 유용하다.
    - 또한 현재 컬렉션 크기보다 큰 인덱스를 지정하면 컬렉션을 해당 인덱스를 수용할 수 있도록 자동 확장할 수 있다.
        - 이때 지정된 인덱스에 요소를 넣기 위해 해당 요소 타입의 기본 생성자를 호출한다. 
        - 만약 기본 생성자가 없다면 null 을 반환한다.
    - 값 설정 방법을 아는 내장 컨버터가 없다면, 즉 설정된 것이 없다면 그 위치는 null 로 남게 된다.

아래는 List 를 자동 확장하는 설정 예제이다.
```java
class Demo {
	public List<String> list;
}

// Turn on:
// - auto null reference initialization
// - auto collection growing
SpelParserConfiguration config = new SpelParserConfiguration(true, true);

ExpressionParser parser = new SpelExpressionParser(config);

Expression expression = parser.parseExpression("list[3]");

Demo demo = new Demo();

Object o = expression.getValue(demo);

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String
```
위 결과로 demo 의 list 는 인덱스 3을 수용할 수 있게 컬렉션 크기가 4로 자동 확장된다.

**SpEL 표현식 최대 길이 설정**
- 표현식은 최대 10,000자까지 허용되나 maxExpressionLength 로 설정 가능하다.
- 코드에서 SpelExpressionParser 를 만들 때 SpelParserConfigutaion 에 최대 길이 설정이 가능하다.
- ApplicationContext 내부(ex. XML 빈정의, @Value 등)에서 파싱 정보를 바꾸고 싶다면 JVM 시스템 프로퍼티나 `spring.context.expression.maxLength` 를 설정하라

## SpEL Compilation
- 스프링은 SpEL 표현식용 기본 컴파일러를 제공한다.
- 표현식은 보통 인터프리터 방식으로 평가되어 평가 중에 동적 유연성을 제공하지만, 성능을 최적화할 수 없다.
    - 인터프리터 방식은 AST 를 생성하고 트리를 따라가며 리플렉션으로 호출을 수행
    - 컴파일 방식은 바이트코드 조작으로 클래스를 생성하여 실제 자바 코드처럼 수행
- 따라서 가끔 사용하는 경우는 괜찮지만, 성능이 중요하고 동적 유연성이 필요하지 않을 땐 컴파일 방식이 나을 수 있다.
- SpEL 컴파일러
    - 평가 중에 표현식 동작을 담은 자바 클래스를 생성하여 더 빠르게 평가할 수 있도록 한다.
    - 표현식엔 정적 타입 정보가 부족하므로, 초기 인터프리터 평가에서 수집한 타입 정보를 활용하여 컴파일한다.
    - 예를 들어 프로퍼티 타입을 표현식만으론 알 수 없으나 첫 인터프리트 평가에서 파악한다.
    - 당연히 이후 타입이 바뀌면 문제가 될 수 있으므로 컴파일 방식은 타입 정보가 동적으로 변하지 않는 표현식에 적합하다.

아래 예제로 인터프리터 vs 컴파일러 방식을 비교하자
```java
someArray[0].someProperty.someOtherProperty < 0.1
```
- 배열 접근, 몇개의 프로퍼티 접근과 수치 연산이 필요하므로 컴파일러 방식을 사용하면 성능 향상이 있을 수 있다.
- 실제로 마이크로 벤치마크 5만회 돌려본 결과 인터프리터는 75ms, 컴파일 버전은 3ms 가 걸렷다.

### Compiler Configuration
- 컴파일러는 기본적으로는 비활성화되어 있다. 
- 활성화 방법
    - ParserConfiguration 사용하여 켜키
    - Spring Property 로 켜기

컴파일러 동작은 `SpelCompilerMode` enum 타입에 정의된 3가지 모드로 동작한다.
- **OFF:** 
    - 비활성화. 
    - 모든 표현식이 인터프리터 방식 (기본값)
- **IMMEDIATE:** 
    - 보통 첫 인터프리터 평가 직후 바로 컴파일, 이후 컴파일된 표현식 평가가 실패하면 exception 이 전달된다.
    - 타입 변동 가능성이 있다면 MIXED 나 OFF 로 바꿀 것을 고려해야 한다.
- **MIXED:** 
    - 인터프리터/컴파일 평가를 내부적으로 전환한다.  
    - 인터프리터 방식이 일정 횟수 이상 성공하면 표현식이 컴파일된다.
    - 컴파일된 표현식 평가가 실패하면 내부에서 ㅈ바아 해당 표현식을 인터프리터 모드로 변환한다.
    - 이후 모드 전환을 하며 계속 재컴파일을 시도할 수 있고,
    - 실패 임계치에 도달하면 영구적으로 해당 표현식을 인터프리터 모드로 바꾼다.
- `IMMEDIATE` 모드는 어떤 부작용이 있는 표현식에 대해선 `MIXED` 모드가 문제를 일으킬 수 있기 때문에 존재한다.
    - MIXED 모드에서 컴파일로 전환되어 평가하다가 부분만 성공 후 실패하였을 때 시스템 상태가 바뀐다면?
    - 이 경우엔 다시 인터프리터 모드로 전환하여 재시도하는 것이 오히려 두번의 실패 결과만 낳을 수 있다. 
```java
SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
		this.getClass().getClassLoader());

SpelExpressionParser parser = new SpelExpressionParser(config);

Expression expr = parser.parseExpression("payload");

MyMessage message = new MyMessage();

Object payload = expr.getValue(message);
```

컴파일러 모드 사용 시 ClassLoader 도 configuration 에 지정 가능하다. 컴파일된 표현식을 제공한 로더의 하위 클래스 로더에 정의된다. ClassLoader 를 지정하면 표현식 평가에 필요한 모든 타입을 볼 수 있어야 한다. 만약, 지정하지 않는다면 표현식이 평가되는 현재 스레드의 컨텍스트 로더가 기본으로 사용된다.

SpEL 설정 객체를 통해 설정이 어려운 경우라면 JVM 시스템 프로퍼티나 spring.expression.compiler.mode property 를 설정할 수 있다.

___

### Compiler Limitations
- 스프링은 모든 유형의 표현식을 컴파일 지원을 하진 않는다.
- 성능이 중요한 문맥에서 흔히 사용되는 표현식에 초점을 두고 있다.
- 컴파일 불가 표현식
    - 대입을 표함한 표현식
    - ConversionService 에 의존하는 표현식
    - custom resolver 를 사용하는 표현식
    - 연산자 오버로딩을 사용하는 표현식 
    - 배열 생성 문법을 사용하는 표현식 
    - 선택 또는 프로젝션을 사용하는 표현식 
    - 빈 참조 표현식