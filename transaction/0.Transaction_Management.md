# Transaction Management (트랜잭션 관리)
- Spring 프레임워크를 사용하는 가장 강력한 이유 중 하나는 포괄적인 트랜잭션 지원이다. 
- 스프링은 일관된 트랜잭션 관리 추상화를 통해 다음 이점을 제공한다.
    - Java Transaction API(JTA), JDBC, hibernate, jpa 등 다양한 트랜잭션 API에 걸쳐 일관된 프로그래밍 모델을 제공한다.
    - 선언적 트랜잭션 관리(declarative transaction management) 지원
    - JTA 같은 복잡한 트랜잭션 API보다 더 간단한 프로그래밍 방식의 트랜잭션 API 제공
    - 스프링의 데이터 접근 추상화 계층과 뛰어난 통합성

## Spring 의 트랜잭션 지원 모델의 이점

전통적으로 EE 애플리케이션 개발자들은 트랜잭션 관리를 위해 글로벌 또는 로컬 중 하나를 선택해야 했다. <br>하지만 이 두 방식은 모두 심오한 제약을 가지고 있다.

### Global Transaction
- 글로벌 트랜잭션은 여러 트랜잭션 리소스(여러 RDBMS 와 메시지큐)와 하나의 트랜잭션으로 처리할 수 있다.
- 글로벌 트랜잭션 사용을 위해선 JTA 를 사용해야 하는데, JTA 는 복잡하고 다루기 힘든 API 이다.
- JTA 구성요소인 UserTransaction 은 JNDI 에서 받아와야 하므로 JTA 사용을 위해선 JNDI 에 대한 의존성도 생긴다.
- JTA 는 오직 애플리케이션 서버 환경에서만 사용할 수 있기 때문에 코드 재사용성이 떨어진다.
- 애플리케이션 서버 환경이 무슨 뜻? JTA 를 지원하는 트랜잭션 매니저가 있는 컨테이너, 즉 실행 환경이 필요하다는 말이다.
- EJB CMT 를 통해 글로벌 트랜잭션을 사용하는 방식이 선호된다.
    - 선언적 트랜잭션 관리 방식을 지원하므로, 코드에 트랜잭션 처리를 직접 쓰진 않아도 된다.
    - JNDI 를 직접 사용하지 않도록 하지만, EJB 자체는 여전히 JNDI 에 의존적이다.
    - 또한 이 방식은 EJB 로 비즈니스 로직을 작성해야만 하는데, EJB 자체가 단점이 크다.

### Local Transaction
- 하나의 트랜잭션 리소스만 처리할 수 있다. ex. JDBC Connection
- 간단하게 사용할 수 있지만 큰 단점이 존재한다.
    - 여러 리소스에 걸친 트랜잭션 처리가 불가능하다.
    - 예를 들어 JDBC 커넥션을 사용하는 로컬 트랜잭션은 JTA 글로벌 트랜잭션에 참여할 수 없다.
    - 글로벌처럼 컨테이너가 트랜잭션 관리를 하지 않으므로 여러 리소스 관리시 트랜잭션 일관성 보장이 안된다.
- 또한 트랜잭션 관리 코드가 로직에 침입할 수 있다.

### Spring 의 일관된 트랜잭션 프로그래밍 모델
- Spring 은 두 글로벌/로컬 트랜잭션에서의 단점을 모두 해결한다.
    - 어떤 환경에서든 개발자가 일관된 프로그래밍을 할 수 있도록 지원한다.
    - 코드를 한 번만 작성하면, 서로 다른 환경에 따라 다른 트랜잭션 전략이 쓰일 수 있다.
    - Spring 은 선언적, 그리고 프로그래밍 방식 모두 지원한다.
    - 개발자는 Spring 의 추상화된 트랜잭션 API 를 사용하여 어떤 인프라에서도 사용할 수 있다.
- 대부분은 `@Transactional` 을 사용하는 선언적 방식을 이용한다.
- 보통 선호되는 선언적 모델에선 코드를 거의 작성하지 않는다. 따라서 트랜잭션 관련 API 에 비즈니스 로직이 의존하지 않아도 된다.
- 유연성
    - 과거엔 로컬 트랜잭션 코드 작성과 글로벌 트랜잭션 간에는 차이가 컸고, 바꾸기 위해선 대대적 수정이 필요했다.
    - 하지만, Spring 에선 트랜잭션 방식이 바뀌어도 코드는 두고, 단지 Bean 설정만 수정하면 된다.






