# Programmatic Transaction Management
## 프로그래밍 방식의 트랜잭션 관리
스프링은 프로그래밍 방식을 두 가지 방법으로 제공
- `TransactionTemplate` 또는 `TransactionOperator` 사용
- `TransactionManager` 구현체 직접 사용

명령형 코드에선 TransactionTemplate 을, reactive 코드에선 TransactionOperator 사용이 권장된다. 

## Using TransactionTemplate
- TransactionTemplate 은 JdbcTemplate 같이 콜백 접근 방식을 사용한다.
    - 이로 인해 애플리케이션 코드가 트랜잭션 리소스 획득 및 해제와 같은 보일러플레이트 코드를 신경 쓸 필요 없다.
    - 핵심 로직은 해당 로직만 신경쓰면 된다.
- TransactionTemplate 사용은 스프링의 트랜잭션 인프라와 API 에 종속된다.
- TransactionTemplate 을 명시적으로 사용해야 할 땐 트랜잭션 내에서 실행할 코드를 포함한 `TransactionCallback` 구현체를 작성할 수 있다.
- 특징
	- TransactionTemplate 객체 인스턴스는 스레드 안전(thread-safe)하다.
	- 즉, 어떠한 상태도 유지하여 공유하지 않는다. 
	- 하지만, 트랜잭션 설정값은 내부적으로 유지하므로 다른 설정이 필요하다면 별도의 인스턴스를 만들어야 한다.
- 내부 예외 발생 시 자동 롤백, 정상 종료 시 자동 커밋이 가능
- 명확한 트랜잭션 경계를 지정할 수 있음 (어디서 시작하고, 어디서 끝날지)
	
```java
public class SimpleService implements Service {

	private final TransactionTemplate transactionTemplate;

	public SimpleService(PlatformTransactionManager transactionManager) {
		this.transactionTemplate = new TransactionTemplate(transactionManager);
	}

	public Object someServiceMethod() {
		return transactionTemplate.execute(new TransactionCallback() {
			// the code in this method runs in a transactional context
			public Object doInTransaction(TransactionStatus status) {
				updateOperation1();
				return resultOfUpdateOperation2();
			}
		});
	}
}
```
트랜잭션 내에서 실행할 로직을 TransactionCallback 구현체로 구현하여 TransactionTemplate 의 execute() 메서드에 콜백으로 전달한다. 보통 익명 내부 클래스로 구현한다.


반환값이 없다면 TransactionCallbackWithoutResult 를 사용할 수 있다.
```java
transactionTemplate.execute(new TransactionCallbackWithoutResult() {
	protected void doInTransactionWithoutResult(TransactionStatus status) {
		updateOperation1();
		updateOperation2();
	}
});
```

콜백 내부 로직에서 메서드로 전달된 `TransactionStatus` 객체로 `setRollbackOnly()` 메서드를 호출함으로써 트랜잭션을 롤백하도록 짤 수도 있다.
```java
transactionTemplate.execute(new TransactionCallbackWithoutResult() {

	protected void doInTransactionWithoutResult(TransactionStatus status) {
		try {
			updateOperation1();
			updateOperation2();
		} catch (SomeBusinessException ex) { // 예외가 터지면 롤백
			status.setRollbackOnly();
		}
	}
```

___

### 트랜잭션 설정하기
- TransactionTemplate 에 대한 트랜잭션 설정(전파, 격리 수준, timeout 등)은 프로그래밍 방식이 configuration 으로 가능하다.
- 설정이 없다면 TransactionTemplate 도 기본적인 트랜잭션 설정을 따른다.

다음은 프로그래밍 방식으로 설정하는 코드이다.
```java
public class SimpleService implements Service {

	private final TransactionTemplate transactionTemplate;

	public SimpleService(PlatformTransactionManager transactionManager) {
		this.transactionTemplate = new TransactionTemplate(transactionManager);

		// 트랜잭션 설정을 명시적으로 설정할 수 있다.
		this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
		this.transactionTemplate.setTimeout(30); // 30초
		
	}
}
```

다음은 xml configuration 으로 설정한 것이다.
```xml
<bean id="sharedTransactionTemplate"
		class="org.springframework.transaction.support.TransactionTemplate">
	<property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/>
	<property name="timeout" value="30"/>
```
위와 같이 sharedTransactionTemplate 빈을 만들어 필요한 곳에 주입하여 사용하면 된다.

## Using TransactionManager
### PlatformTransactionManager
- PlatformTransactionManager 구현체를 빈 참조에 주입하여 사용하여 트랜잭션을 직접 관리한다.
- 그리고 `TransactionDefinition`, `TransactionStatus` 객체를 사용하여 트랜잭션을 시작, 롤백, 커밋할 수 있다.
	- TransactionDefinition: 트랜잭션 설정값
	- TransactionStatus: 트랜잭션 상태를 추적하여 조작
- 개발자가 직접 try-catch-finally 로 직접 트랜잭션 커밋, 롤백 등 제어 필요, 가장 세밀한 제어가 가능
	- TransactionTemplate 보다 더 저수준
```java
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
	// put your business logic here
} catch (MyException ex) {
	txManager.rollback(status);
	throw ex;
}
txManager.commit(status);
```

### ReactiveTransactionManager
```java
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

Mono<ReactiveTransaction> reactiveTx = txManager.getReactiveTransaction(def);

reactiveTx.flatMap(status -> {

	Mono<Object> tx = ...; // put your business logic here

	return tx.then(txManager.commit(status))
			.onErrorResume(ex -> txManager.rollback(status).then(Mono.error(ex)));
});
```

