# Dependency Injection
## 의존성 주입(Dependency Injection) 이란?
- 의존성 주입은 객체가 생성자 파라미터, 팩터리 메서드 파라미터 등 설정된 속성을 통해서만 객체의 종속성을 정의하는 프로세스다. 
- 스프링 컨테이너는 이러한 의존성 설정을 보고 먼저, 빈이 생성된 후 의존관계를 주입한다.
- 제어의 역전(IoC) 의 일종으로, 직접 필요한 객체를 구성하는 기존 방식과는 반대되는 프로세스이다. 
- DI 는 코드를 깔끔하게 만들고, 외부에서 주입받으므로 결합도가 낮아져 분리(decoupling)에 효과적이다. 
    - 의존관계에 있는 객체가 어디 있고 어떤 클래스인지 구체적으로 알 필요가 없다.
    - 외부에서 주입받아서 사용하기만 사용된다. 
- 결과적으로 테스트하기도 쉬워진다. 
    - 즉, 외부에서 주입받는 자리에 가짜 구현체(Mock 객체)를 주입받아 단위 테스트를 수행할 수 있다.
- DI 방식 종류
    - 생성자 주입
    - 수정자 주입 (setter 주입)
    - 필드 주입
    - 일반 메서드 주입

### 생성자 주입(Constructor-based Dependency Injection)
- 말 그대로 생성자를 통해서 의존성 객체를 주입받는다. 
- 필요한 의존성 객체 파라미터를 가진 생성자를 호출하면서 주입받는다.

다음은 `final` 필드 때문에 오직 생성자 주입으로만 가능한 예시이다.
```java
public class SimpleMovieLister {

	// the SimpleMovieLister has a dependency on a MovieFinder
	private final MovieFinder movieFinder;

	// a constructor so that the Spring container can inject a MovieFinder
	public SimpleMovieLister(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}

	// business logic that actually uses the injected MovieFinder is omitted...
}
```
**생성자가 딱 1개만 있으면 `@Autowired` 를 붙이지 않아도 자동 주입된다.** 

___

### 수정자 주입(Setter-based Dependency Injection)
- setter 메서드 호출을 통해 의존성 객체를 주입하는 방식이다.
- setter 의 장점은 세터를 통해 의존성을 재설정, 재주입할 수 있다는 것이다.
```java
public class SimpleMovieLister {

	// the SimpleMovieLister has a dependency on the MovieFinder
	private MovieFinder movieFinder;

	// a setter method so that the Spring container can inject a MovieFinder
	public void setMovieFinder(MovieFinder movieFinder) {
		this.movieFinder = movieFinder;
	}

	// business logic that actually uses the injected MovieFinder is omitted...
}
```
- 일부 의존성은 생성자 주입으로 주입된 후, 추가적인 의존성을 setter 주입으로 하는 것도 가능하다.
- 의존성 설정 정보는 내부적으로 BeanDefinition 이라는 인스턴스로 변환되어 Spring 컨테이너가 사용한다.

___

### 필드 주입
- 이름 그대로 필드에 바로 주입하는 방식 + @Autowired
- 특징
    - 코드가 매우 간결해서 편하지만 외부에서 변경이 불가능하여 테스트하기가 어려워진다는 단점이 존재한다.
    - DI 프레임워크가 없으면 아무것도 할 수 없는 코드이다.
    - 사용하지 마라!!
        - 애플리케이션의 실제 코드와 관계 없는 테스트 코드에서만 사용
        - 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

___

### 생성자 주입 vs 수정자 주입
- 둘은 혼합해서 사용할 수 있으며 필수 의존성은 생성자로 주입하고, 선택 의존성은 setter 로 주입할 수 있다.
- @Autowired + setter 를 사용하면 필수 의존성으로 만들 순 있으나, **생성자 주입을 사용하고 내부에서 유효성 검사를 해주는 방식이 권장된다.**
- Spring 에선 일반적으로 생성자 주입을 권장한다. 
    - 컴포넌트를 **불변** 객체로 만들 수 있고, 필수 의존성이 null 이 아님을 보장할 수 있다.
    - 대부분 의존관계 주입은 한번 일어나면 app 종료 시점까지 변경할 일이 없고, 변하면 안된다.
    - 생성자 주입은 생성 시 딱 1번 호출되므로 불변하게 설계할 수 있다.
    - 또한, 필수 의존성 누락 시 생성 시에 컴파일 오류로 초기에 바로 잡을 수 있다.
    - 수정자 주입은 setter 를 public 으로 열어두어야 한다.
- 또한 생성자 주입 방식은 프레임워크에 의존하지 않고, 순수 자바 언어의 특징을 살릴 수 있는 방법이다.
- 하지만, 생성자에 인자가 너무 많다면 나쁜 코드이다. 
    - 이는 해당 클래스가 너무 많은 책임을 가지고 있음을 의미하기도 한다.
    - 따라서 관심사를 분리하여 클래스를 분리하고 리팩토링하는 것이 바람직하다.
- setter 주입은 선택적인 의존성인 경우에만 사용하고, 내부에서 기본값을 설정할 수 있는 경우에 사용하라

최근에는 생성자를 딱 1개 두고, @Autowired 를 생략하는 방법을 주로 많이 쓴다고 한다. 

## @RequiredArgsConstructor
- 생성자 주입은 생성자로 대입하는 코드를 직접 작성한다. 
- 필드 주입처럼 간편하게 사용할 수 있는 방법으로 `@RequiredArgsConstructor` 을 롬복에서 제공한다.
- 롬복의 @RequiredArgsConstructor 는 final 필드를 모아서 생성자를 자동 생성한다.
    - 생성자가 실제로는 눈에 보이지 않아도 호출이 가능하다!
    - 롬복은 AnnotionProcessor 기능을 이용하여 컴파일 시점에 생성자 코드를 자동으로 생성한다.
```java

@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    
}
```

